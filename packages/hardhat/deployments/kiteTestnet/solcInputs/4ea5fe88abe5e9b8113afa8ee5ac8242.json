{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/ProjectEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title ProjectEscrow\n * @notice Milestone-based escrow with per-milestone assignment and explicit acceptance\n * @dev Designed for AI-compatible worker matching - each milestone can have a different assignee\n *\n * State Machine:\n *   Created → Assigned → Accepted → InProgress → Submitted → Approved → Paid\n *                     ↘ Declined (returns to Created, clears assignee)\n *\n * Roles:\n *   - Client: Project owner, funds milestones, approves/rejects work\n *   - PM: Optional project manager, can assign workers, earns commission\n *   - Assignee: Worker assigned to a specific milestone (can vary per milestone)\n */\ncontract ProjectEscrow is ReentrancyGuard {\n    enum MilestoneStatus {\n        Created,    // Initial state, no assignee\n        Assigned,   // Assignee set, waiting for acceptance\n        Accepted,   // Assignee accepted, can start work\n        InProgress, // Work started\n        Submitted,  // Work submitted for review\n        Approved,   // Client approved (legacy, for backwards compat)\n        Paid        // Payment released\n    }\n\n    struct Milestone {\n        string description;\n        uint256 amount;\n        address assignee;           // Worker assigned to this milestone\n        uint256 createdAt;\n        uint256 assignedAt;         // When assignee was set\n        uint256 acceptedAt;         // When assignee accepted\n        uint256 submittedAt;\n        MilestoneStatus status;\n        string submissionNote;\n    }\n\n    struct Project {\n        address client;\n        address pm;                 // Optional project manager\n        uint256 pmFeeBps;           // PM fee in basis points (0-2000)\n        uint256 totalAmount;\n        uint256 totalPaid;\n        uint256 totalPmFees;\n        bool active;\n        Milestone[] milestones;\n    }\n\n    uint256 public projectCount;\n    mapping(uint256 => Project) public projects;\n\n    uint256 public constant TIMEOUT_PERIOD = 14 days;\n    uint256 public constant ASSIGNMENT_TIMEOUT = 7 days;  // Auto-decline if not accepted\n    uint256 public constant MIN_MILESTONE_AMOUNT = 0.001 ether;\n    uint256 public constant MAX_PM_FEE_BPS = 2000; // 20%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    // ============ Events ============\n\n    event ProjectCreated(\n        uint256 indexed projectId,\n        address indexed client,\n        address pm,\n        uint256 pmFeeBps,\n        uint256 totalAmount,\n        uint256 milestoneCount\n    );\n\n    event MilestoneAssigned(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        address indexed assignee,\n        address indexed assignedBy\n    );\n\n    event MilestoneAccepted(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        address indexed assignee\n    );\n\n    event MilestoneDeclined(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        address indexed assignee,\n        string reason\n    );\n\n    event MilestoneUnassigned(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        address indexed previousAssignee\n    );\n\n    event MilestoneStarted(uint256 indexed projectId, uint256 milestoneIndex);\n\n    event MilestoneSubmitted(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        string note\n    );\n\n    event MilestoneApproved(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        uint256 assigneeAmount,\n        uint256 pmFee\n    );\n\n    event MilestoneRejected(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        string reason\n    );\n\n    event MilestonePaid(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        uint256 amount,\n        bool autoReleased\n    );\n\n    event ProjectCancelled(uint256 indexed projectId, uint256 refundAmount);\n\n    // ============ Modifiers ============\n\n    modifier onlyClient(uint256 projectId) {\n        require(msg.sender == projects[projectId].client, \"Only client\");\n        _;\n    }\n\n    modifier onlyClientOrPM(uint256 projectId) {\n        Project storage project = projects[projectId];\n        require(\n            msg.sender == project.client ||\n            (project.pm != address(0) && msg.sender == project.pm),\n            \"Only client or PM\"\n        );\n        _;\n    }\n\n    modifier onlyAssignee(uint256 projectId, uint256 milestoneIndex) {\n        require(\n            msg.sender == projects[projectId].milestones[milestoneIndex].assignee,\n            \"Only assignee\"\n        );\n        _;\n    }\n\n    modifier projectActive(uint256 projectId) {\n        require(projects[projectId].active, \"Project not active\");\n        _;\n    }\n\n    modifier validMilestoneIndex(uint256 projectId, uint256 milestoneIndex) {\n        require(milestoneIndex < projects[projectId].milestones.length, \"Invalid milestone index\");\n        _;\n    }\n\n    // ============ Project Creation ============\n\n    /**\n     * @notice Create new project with milestones and optional PM\n     * @param pm Address of the project manager (can be address(0) for no PM)\n     * @param pmFeeBps PM fee in basis points (0-2000, i.e., 0-20%)\n     * @param descriptions Array of milestone descriptions\n     * @param amounts Array of milestone amounts (in wei)\n     * @param initialAssignees Optional array of initial assignees (can contain address(0))\n     */\n    function createProject(\n        address pm,\n        uint256 pmFeeBps,\n        string[] memory descriptions,\n        uint256[] memory amounts,\n        address[] memory initialAssignees\n    ) external payable returns (uint256) {\n        require(descriptions.length == amounts.length, \"Array length mismatch\");\n        require(descriptions.length > 0, \"Need at least one milestone\");\n        require(descriptions.length <= 50, \"Too many milestones\");\n        require(pmFeeBps <= MAX_PM_FEE_BPS, \"PM fee too high\");\n\n        // Handle initialAssignees - can be empty or same length as descriptions\n        require(\n            initialAssignees.length == 0 || initialAssignees.length == descriptions.length,\n            \"Assignees array length mismatch\"\n        );\n\n        // PM validation\n        if (pm != address(0)) {\n            require(pm != msg.sender, \"Client cannot be PM\");\n        } else {\n            require(pmFeeBps == 0, \"Cannot set fee without PM\");\n        }\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= MIN_MILESTONE_AMOUNT, \"Amount too small\");\n            require(bytes(descriptions[i]).length > 0, \"Description required\");\n            require(bytes(descriptions[i]).length <= 500, \"Description too long\");\n\n            // Validate assignee if provided\n            if (initialAssignees.length > 0 && initialAssignees[i] != address(0)) {\n                require(initialAssignees[i] != msg.sender, \"Client cannot be assignee\");\n                require(initialAssignees[i] != pm, \"PM cannot be assignee\");\n            }\n\n            total += amounts[i];\n        }\n        require(msg.value == total, \"Incorrect payment amount\");\n\n        uint256 projectId = projectCount++;\n        Project storage project = projects[projectId];\n        project.client = msg.sender;\n        project.pm = pm;\n        project.pmFeeBps = pmFeeBps;\n        project.totalAmount = total;\n        project.totalPaid = 0;\n        project.totalPmFees = 0;\n        project.active = true;\n\n        for (uint256 i = 0; i < descriptions.length; i++) {\n            address assignee = initialAssignees.length > 0 ? initialAssignees[i] : address(0);\n            MilestoneStatus initialStatus = assignee != address(0)\n                ? MilestoneStatus.Assigned\n                : MilestoneStatus.Created;\n\n            project.milestones.push(Milestone({\n                description: descriptions[i],\n                amount: amounts[i],\n                assignee: assignee,\n                createdAt: block.timestamp,\n                assignedAt: assignee != address(0) ? block.timestamp : 0,\n                acceptedAt: 0,\n                submittedAt: 0,\n                status: initialStatus,\n                submissionNote: \"\"\n            }));\n\n            if (assignee != address(0)) {\n                emit MilestoneAssigned(projectId, i, assignee, msg.sender);\n            }\n        }\n\n        emit ProjectCreated(projectId, msg.sender, pm, pmFeeBps, total, descriptions.length);\n        return projectId;\n    }\n\n    // ============ Assignment Functions ============\n\n    /**\n     * @notice Assign a worker to a milestone\n     * @dev Can be called by client or PM. Worker must then accept.\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     * @param assignee Address of the worker to assign\n     */\n    function assignMilestone(\n        uint256 projectId,\n        uint256 milestoneIndex,\n        address assignee\n    )\n        external\n        onlyClientOrPM(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Project storage project = projects[projectId];\n        Milestone storage milestone = project.milestones[milestoneIndex];\n\n        require(milestone.status == MilestoneStatus.Created, \"Milestone not in Created status\");\n        require(assignee != address(0), \"Invalid assignee address\");\n        require(assignee != project.client, \"Client cannot be assignee\");\n        require(assignee != project.pm, \"PM cannot be assignee\");\n\n        milestone.assignee = assignee;\n        milestone.assignedAt = block.timestamp;\n        milestone.status = MilestoneStatus.Assigned;\n\n        emit MilestoneAssigned(projectId, milestoneIndex, assignee, msg.sender);\n    }\n\n    /**\n     * @notice Accept an assigned milestone\n     * @dev Can only be called by the assignee\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function acceptMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyAssignee(projectId, milestoneIndex)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Assigned, \"Milestone not in Assigned status\");\n\n        milestone.acceptedAt = block.timestamp;\n        milestone.status = MilestoneStatus.Accepted;\n\n        emit MilestoneAccepted(projectId, milestoneIndex, msg.sender);\n    }\n\n    /**\n     * @notice Decline an assigned milestone\n     * @dev Can only be called by the assignee. Returns milestone to Created status.\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     * @param reason Reason for declining\n     */\n    function declineMilestone(uint256 projectId, uint256 milestoneIndex, string memory reason)\n        external\n        onlyAssignee(projectId, milestoneIndex)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Assigned, \"Milestone not in Assigned status\");\n\n        address previousAssignee = milestone.assignee;\n\n        milestone.assignee = address(0);\n        milestone.assignedAt = 0;\n        milestone.status = MilestoneStatus.Created;\n\n        emit MilestoneDeclined(projectId, milestoneIndex, previousAssignee, reason);\n    }\n\n    /**\n     * @notice Unassign a worker from a milestone\n     * @dev Can be called by client or PM. Only works for Assigned status (before acceptance).\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function unassignMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyClientOrPM(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Assigned, \"Can only unassign from Assigned status\");\n\n        address previousAssignee = milestone.assignee;\n\n        milestone.assignee = address(0);\n        milestone.assignedAt = 0;\n        milestone.status = MilestoneStatus.Created;\n\n        emit MilestoneUnassigned(projectId, milestoneIndex, previousAssignee);\n    }\n\n    /**\n     * @notice Auto-unassign if assignment timeout passed\n     * @dev Anyone can call this to clean up stale assignments\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function expireAssignment(uint256 projectId, uint256 milestoneIndex)\n        external\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Assigned, \"Not in Assigned status\");\n        require(\n            block.timestamp >= milestone.assignedAt + ASSIGNMENT_TIMEOUT,\n            \"Assignment not expired\"\n        );\n\n        address previousAssignee = milestone.assignee;\n\n        milestone.assignee = address(0);\n        milestone.assignedAt = 0;\n        milestone.status = MilestoneStatus.Created;\n\n        emit MilestoneUnassigned(projectId, milestoneIndex, previousAssignee);\n    }\n\n    // ============ Work Functions ============\n\n    /**\n     * @notice Start working on a milestone\n     * @dev Can only be called by assignee after accepting\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function startMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyAssignee(projectId, milestoneIndex)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Accepted, \"Milestone not in Accepted status\");\n\n        milestone.status = MilestoneStatus.InProgress;\n        emit MilestoneStarted(projectId, milestoneIndex);\n    }\n\n    /**\n     * @notice Submit completed work for review\n     * @dev Can be called from Accepted or InProgress status\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     * @param note Submission note describing deliverables\n     */\n    function submitMilestone(uint256 projectId, uint256 milestoneIndex, string memory note)\n        external\n        onlyAssignee(projectId, milestoneIndex)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(\n            milestone.status == MilestoneStatus.Accepted ||\n            milestone.status == MilestoneStatus.InProgress,\n            \"Cannot submit from current status\"\n        );\n\n        milestone.status = MilestoneStatus.Submitted;\n        milestone.submittedAt = block.timestamp;\n        milestone.submissionNote = note;\n\n        emit MilestoneSubmitted(projectId, milestoneIndex, note);\n    }\n\n    // ============ Approval Functions ============\n\n    /**\n     * @notice Approve a milestone and trigger payment\n     * @dev Only client can approve. Pays assignee minus PM fee.\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function approveMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        nonReentrant\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Project storage project = projects[projectId];\n        Milestone storage milestone = project.milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Submitted, \"Milestone not submitted\");\n\n        // Calculate PM fee\n        uint256 pmFee = (milestone.amount * project.pmFeeBps) / BPS_DENOMINATOR;\n        uint256 assigneeAmount = milestone.amount - pmFee;\n\n        // Update state before external calls\n        milestone.status = MilestoneStatus.Paid;\n        project.totalPaid += milestone.amount;\n        project.totalPmFees += pmFee;\n\n        // Transfer to assignee\n        (bool s1,) = milestone.assignee.call{value: assigneeAmount}(\"\");\n        require(s1, \"Assignee transfer failed\");\n\n        // Transfer to PM (if exists and fee > 0)\n        if (project.pm != address(0) && pmFee > 0) {\n            (bool s2,) = project.pm.call{value: pmFee}(\"\");\n            require(s2, \"PM transfer failed\");\n        }\n\n        emit MilestoneApproved(projectId, milestoneIndex, assigneeAmount, pmFee);\n    }\n\n    /**\n     * @notice Reject a milestone submission\n     * @dev Returns milestone to InProgress status for revision\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     * @param reason Reason for rejection\n     */\n    function rejectMilestone(uint256 projectId, uint256 milestoneIndex, string memory reason)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Submitted, \"Milestone not submitted\");\n\n        milestone.status = MilestoneStatus.InProgress;\n        milestone.submittedAt = 0;\n        milestone.submissionNote = \"\";\n\n        emit MilestoneRejected(projectId, milestoneIndex, reason);\n    }\n\n    // ============ Release & Cancel Functions ============\n\n    /**\n     * @notice Release payment for approved milestone (legacy) or auto-release after timeout\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function releaseMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        nonReentrant\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Project storage project = projects[projectId];\n        require(project.active, \"Project not active\");\n\n        Milestone storage milestone = project.milestones[milestoneIndex];\n        require(milestone.status != MilestoneStatus.Paid, \"Already paid\");\n        require(milestone.assignee != address(0), \"No assignee\");\n\n        bool isApproved = milestone.status == MilestoneStatus.Approved;\n        bool isSubmittedAndTimedOut =\n            milestone.status == MilestoneStatus.Submitted &&\n            milestone.submittedAt > 0 &&\n            block.timestamp >= milestone.submittedAt + TIMEOUT_PERIOD;\n\n        require(isApproved || isSubmittedAndTimedOut, \"Not ready to release\");\n\n        // Calculate PM fee\n        uint256 pmFee = (milestone.amount * project.pmFeeBps) / BPS_DENOMINATOR;\n        uint256 assigneeAmount = milestone.amount - pmFee;\n\n        // Update state before external calls\n        milestone.status = MilestoneStatus.Paid;\n        project.totalPaid += milestone.amount;\n        project.totalPmFees += pmFee;\n\n        // Transfer to assignee\n        (bool s1,) = milestone.assignee.call{value: assigneeAmount}(\"\");\n        require(s1, \"Transfer failed\");\n\n        // Transfer to PM (if exists and fee > 0)\n        if (project.pm != address(0) && pmFee > 0) {\n            (bool s2,) = project.pm.call{value: pmFee}(\"\");\n            require(s2, \"PM transfer failed\");\n        }\n\n        emit MilestonePaid(projectId, milestoneIndex, milestone.amount, isSubmittedAndTimedOut);\n    }\n\n    /**\n     * @notice Cancel project and refund unpaid milestones\n     * @dev Can only cancel if no milestones are submitted or in progress with work done\n     * @param projectId The project ID\n     */\n    function cancelProject(uint256 projectId)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        nonReentrant\n    {\n        Project storage project = projects[projectId];\n\n        uint256 refundAmount = 0;\n        bool hasActiveWork = false;\n\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            MilestoneStatus status = project.milestones[i].status;\n            // Cannot cancel if there's submitted work or approved work\n            if (status == MilestoneStatus.Approved || status == MilestoneStatus.Submitted) {\n                hasActiveWork = true;\n                break;\n            }\n            if (status != MilestoneStatus.Paid) {\n                refundAmount += project.milestones[i].amount;\n            }\n        }\n\n        require(!hasActiveWork, \"Cannot cancel with submitted or approved milestones\");\n        require(refundAmount > 0, \"No funds to refund\");\n\n        project.active = false;\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            if (project.milestones[i].status != MilestoneStatus.Paid) {\n                project.milestones[i].status = MilestoneStatus.Paid;\n            }\n        }\n\n        (bool success, ) = project.client.call{value: refundAmount}(\"\");\n        require(success, \"Refund failed\");\n\n        emit ProjectCancelled(projectId, refundAmount);\n    }\n\n    /**\n     * @notice Emergency reclaim for stalled milestones\n     * @dev Client can reclaim funds after extended timeout\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function emergencyReclaim(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n        nonReentrant\n    {\n        Project storage project = projects[projectId];\n        Milestone storage milestone = project.milestones[milestoneIndex];\n\n        require(milestone.status != MilestoneStatus.Paid, \"Already paid\");\n        require(\n            milestone.status != MilestoneStatus.Approved &&\n            milestone.status != MilestoneStatus.Submitted,\n            \"Cannot reclaim approved or submitted milestone\"\n        );\n\n        uint256 emergencyTimeout = milestone.createdAt + (TIMEOUT_PERIOD * 2);\n        require(block.timestamp >= emergencyTimeout, \"Emergency timeout not reached\");\n\n        milestone.status = MilestoneStatus.Paid;\n\n        (bool success, ) = project.client.call{value: milestone.amount}(\"\");\n        require(success, \"Emergency reclaim failed\");\n\n        emit MilestonePaid(projectId, milestoneIndex, milestone.amount, true);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get project details\n     */\n    function getProject(uint256 projectId) external view returns (\n        address client,\n        address pm,\n        uint256 pmFeeBps,\n        uint256 totalAmount,\n        uint256 totalPaid,\n        uint256 totalPmFees,\n        bool active,\n        uint256 milestoneCount\n    ) {\n        Project storage project = projects[projectId];\n        return (\n            project.client,\n            project.pm,\n            project.pmFeeBps,\n            project.totalAmount,\n            project.totalPaid,\n            project.totalPmFees,\n            project.active,\n            project.milestones.length\n        );\n    }\n\n    /**\n     * @notice Get milestone basic details\n     */\n    function getMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        view\n        validMilestoneIndex(projectId, milestoneIndex)\n        returns (\n            string memory description,\n            uint256 amount,\n            address assignee,\n            MilestoneStatus status,\n            uint256 createdAt,\n            uint256 submittedAt,\n            string memory submissionNote\n        )\n    {\n        Milestone storage m = projects[projectId].milestones[milestoneIndex];\n        return (m.description, m.amount, m.assignee, m.status, m.createdAt, m.submittedAt, m.submissionNote);\n    }\n\n    /**\n     * @notice Get milestone timestamps\n     */\n    function getMilestoneTimestamps(uint256 projectId, uint256 milestoneIndex)\n        external\n        view\n        validMilestoneIndex(projectId, milestoneIndex)\n        returns (\n            uint256 createdAt,\n            uint256 assignedAt,\n            uint256 acceptedAt,\n            uint256 submittedAt,\n            bool canAutoRelease\n        )\n    {\n        Milestone storage m = projects[projectId].milestones[milestoneIndex];\n        bool autoRelease = m.status == MilestoneStatus.Submitted &&\n            m.submittedAt > 0 &&\n            block.timestamp >= m.submittedAt + TIMEOUT_PERIOD;\n        return (m.createdAt, m.assignedAt, m.acceptedAt, m.submittedAt, autoRelease);\n    }\n\n    /**\n     * @notice Get all milestones for a project\n     */\n    function getAllMilestones(uint256 projectId) external view returns (\n        string[] memory descriptions,\n        uint256[] memory amounts,\n        address[] memory assignees,\n        MilestoneStatus[] memory statuses,\n        uint256[] memory submittedAts,\n        string[] memory submissionNotes\n    ) {\n        Project storage project = projects[projectId];\n        uint256 length = project.milestones.length;\n\n        descriptions = new string[](length);\n        amounts = new uint256[](length);\n        assignees = new address[](length);\n        statuses = new MilestoneStatus[](length);\n        submittedAts = new uint256[](length);\n        submissionNotes = new string[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Milestone storage milestone = project.milestones[i];\n            descriptions[i] = milestone.description;\n            amounts[i] = milestone.amount;\n            assignees[i] = milestone.assignee;\n            statuses[i] = milestone.status;\n            submittedAts[i] = milestone.submittedAt;\n            submissionNotes[i] = milestone.submissionNote;\n        }\n\n        return (descriptions, amounts, assignees, statuses, submittedAts, submissionNotes);\n    }\n\n    /**\n     * @notice Get project statistics\n     */\n    function getProjectStats(uint256 projectId) external view returns (\n        uint256 totalMilestones,\n        uint256 completedMilestones,\n        uint256 paidMilestones,\n        uint256 remainingAmount,\n        uint256 assignedMilestones,\n        uint256 acceptedMilestones\n    ) {\n        Project storage project = projects[projectId];\n        uint256 completed = 0;\n        uint256 paid = 0;\n        uint256 assigned = 0;\n        uint256 accepted = 0;\n\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            MilestoneStatus status = project.milestones[i].status;\n\n            if (status == MilestoneStatus.Assigned) {\n                assigned++;\n            }\n            if (status == MilestoneStatus.Accepted ||\n                status == MilestoneStatus.InProgress ||\n                status == MilestoneStatus.Submitted ||\n                status == MilestoneStatus.Approved ||\n                status == MilestoneStatus.Paid) {\n                accepted++;\n            }\n            if (status == MilestoneStatus.Approved || status == MilestoneStatus.Paid) {\n                completed++;\n            }\n            if (status == MilestoneStatus.Paid) {\n                paid++;\n            }\n        }\n\n        return (\n            project.milestones.length,\n            completed,\n            paid,\n            project.totalAmount - project.totalPaid,\n            assigned,\n            accepted\n        );\n    }\n\n    /**\n     * @notice Check if address is involved in a project\n     */\n    function getAddressRole(uint256 projectId, address addr) external view returns (\n        bool isClient,\n        bool isPM,\n        uint256[] memory assignedMilestones\n    ) {\n        Project storage project = projects[projectId];\n\n        isClient = project.client == addr;\n        isPM = project.pm == addr;\n\n        // Count how many milestones this address is assigned to\n        uint256 count = 0;\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            if (project.milestones[i].assignee == addr) {\n                count++;\n            }\n        }\n\n        assignedMilestones = new uint256[](count);\n        uint256 j = 0;\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            if (project.milestones[i].assignee == addr) {\n                assignedMilestones[j++] = i;\n            }\n        }\n\n        return (isClient, isPM, assignedMilestones);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}