{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/MilestoneEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title MilestoneEscrow\n * @notice Milestone-based escrow for freelance payments with PM fee mechanism\n * @dev Enhanced version with status state machine, PM fees, and role-based actions\n */\ncontract MilestoneEscrow is ReentrancyGuard {\n    enum MilestoneStatus { Created, InProgress, Submitted, Approved, Paid }\n\n    struct Milestone {\n        string description;\n        uint256 amount;\n        uint256 createdAt;\n        uint256 submittedAt;\n        MilestoneStatus status;\n        string submissionNote;\n    }\n\n    struct Project {\n        address client;\n        address freelancer;\n        address pm;\n        uint256 pmFeeBps;\n        uint256 totalAmount;\n        uint256 totalPaid;\n        uint256 totalPmFees;\n        bool active;\n        Milestone[] milestones;\n    }\n\n    uint256 public projectCount;\n    mapping(uint256 => Project) public projects;\n\n    uint256 public constant TIMEOUT_PERIOD = 14 days;\n    uint256 public constant MIN_MILESTONE_AMOUNT = 0.001 ether;\n    uint256 public constant MAX_PM_FEE_BPS = 2000; // 20%\n    uint256 public constant BPS_DENOMINATOR = 10000;\n\n    event ProjectCreated(\n        uint256 indexed projectId,\n        address indexed client,\n        address indexed freelancer,\n        address pm,\n        uint256 pmFeeBps,\n        uint256 totalAmount,\n        uint256 milestoneCount\n    );\n    event MilestoneStarted(uint256 indexed projectId, uint256 milestoneIndex);\n    event MilestoneSubmitted(uint256 indexed projectId, uint256 milestoneIndex, string note);\n    event MilestoneApproved(uint256 indexed projectId, uint256 milestoneIndex, uint256 freelancerAmount, uint256 pmFee);\n    event MilestoneRejected(uint256 indexed projectId, uint256 milestoneIndex, string reason);\n    event MilestoneCompleted(uint256 indexed projectId, uint256 milestoneIndex);\n    event MilestonePaid(\n        uint256 indexed projectId,\n        uint256 milestoneIndex,\n        uint256 amount,\n        bool autoReleased\n    );\n    event ProjectCancelled(uint256 indexed projectId, uint256 refundAmount);\n\n    modifier onlyClient(uint256 projectId) {\n        require(msg.sender == projects[projectId].client, \"Only client\");\n        _;\n    }\n\n    modifier onlyFreelancer(uint256 projectId) {\n        require(msg.sender == projects[projectId].freelancer, \"Only freelancer\");\n        _;\n    }\n\n    modifier projectActive(uint256 projectId) {\n        require(projects[projectId].active, \"Project not active\");\n        _;\n    }\n\n    modifier validMilestoneIndex(uint256 projectId, uint256 milestoneIndex) {\n        require(milestoneIndex < projects[projectId].milestones.length, \"Invalid milestone index\");\n        _;\n    }\n\n    /**\n     * @notice Create new project with milestones and optional PM\n     * @param freelancer Address of the freelancer\n     * @param pm Address of the project manager (can be address(0) for no PM)\n     * @param pmFeeBps PM fee in basis points (0-2000, i.e., 0-20%)\n     * @param descriptions Array of milestone descriptions\n     * @param amounts Array of milestone amounts (in wei)\n     */\n    function createProject(\n        address freelancer,\n        address pm,\n        uint256 pmFeeBps,\n        string[] memory descriptions,\n        uint256[] memory amounts\n    ) external payable returns (uint256) {\n        require(freelancer != address(0), \"Invalid freelancer address\");\n        require(freelancer != msg.sender, \"Client cannot be freelancer\");\n        require(descriptions.length == amounts.length, \"Array length mismatch\");\n        require(descriptions.length > 0, \"Need at least one milestone\");\n        require(descriptions.length <= 50, \"Too many milestones\");\n        require(pmFeeBps <= MAX_PM_FEE_BPS, \"PM fee too high\");\n\n        // If PM is set, fee must be > 0; if no PM, fee must be 0\n        if (pm != address(0)) {\n            require(pm != msg.sender, \"Client cannot be PM\");\n            require(pm != freelancer, \"Freelancer cannot be PM\");\n        } else {\n            require(pmFeeBps == 0, \"Cannot set fee without PM\");\n        }\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            require(amounts[i] >= MIN_MILESTONE_AMOUNT, \"Amount too small\");\n            require(bytes(descriptions[i]).length > 0, \"Description required\");\n            require(bytes(descriptions[i]).length <= 500, \"Description too long\");\n            total += amounts[i];\n        }\n        require(msg.value == total, \"Incorrect payment amount\");\n\n        uint256 projectId = projectCount++;\n        Project storage project = projects[projectId];\n        project.client = msg.sender;\n        project.freelancer = freelancer;\n        project.pm = pm;\n        project.pmFeeBps = pmFeeBps;\n        project.totalAmount = total;\n        project.totalPaid = 0;\n        project.totalPmFees = 0;\n        project.active = true;\n\n        for (uint256 i = 0; i < descriptions.length; i++) {\n            project.milestones.push(Milestone({\n                description: descriptions[i],\n                amount: amounts[i],\n                createdAt: block.timestamp,\n                submittedAt: 0,\n                status: MilestoneStatus.Created,\n                submissionNote: \"\"\n            }));\n        }\n\n        emit ProjectCreated(projectId, msg.sender, freelancer, pm, pmFeeBps, total, descriptions.length);\n        return projectId;\n    }\n\n    /**\n     * @notice Freelancer starts working on a milestone\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function startMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyFreelancer(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Created, \"Milestone not in Created status\");\n\n        milestone.status = MilestoneStatus.InProgress;\n        emit MilestoneStarted(projectId, milestoneIndex);\n    }\n\n    /**\n     * @notice Freelancer submits a completed milestone\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     * @param note Submission note describing deliverables\n     */\n    function submitMilestone(uint256 projectId, uint256 milestoneIndex, string memory note)\n        external\n        onlyFreelancer(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(\n            milestone.status == MilestoneStatus.InProgress || milestone.status == MilestoneStatus.Created,\n            \"Cannot submit from current status\"\n        );\n\n        milestone.status = MilestoneStatus.Submitted;\n        milestone.submittedAt = block.timestamp;\n        milestone.submissionNote = note;\n\n        emit MilestoneSubmitted(projectId, milestoneIndex, note);\n    }\n\n    /**\n     * @notice Client approves a milestone and triggers payment\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function approveMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        nonReentrant\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Project storage project = projects[projectId];\n        Milestone storage milestone = project.milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Submitted, \"Milestone not submitted\");\n\n        // Calculate PM fee\n        uint256 pmFee = (milestone.amount * project.pmFeeBps) / BPS_DENOMINATOR;\n        uint256 freelancerAmount = milestone.amount - pmFee;\n\n        // Update state before external calls\n        milestone.status = MilestoneStatus.Paid;\n        project.totalPaid += milestone.amount;\n        project.totalPmFees += pmFee;\n\n        // Transfer to freelancer\n        (bool s1,) = project.freelancer.call{value: freelancerAmount}(\"\");\n        require(s1, \"Freelancer transfer failed\");\n\n        // Transfer to PM (if exists and fee > 0)\n        if (project.pm != address(0) && pmFee > 0) {\n            (bool s2,) = project.pm.call{value: pmFee}(\"\");\n            require(s2, \"PM transfer failed\");\n        }\n\n        emit MilestoneApproved(projectId, milestoneIndex, freelancerAmount, pmFee);\n    }\n\n    /**\n     * @notice Client rejects a milestone submission\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     * @param reason Reason for rejection\n     */\n    function rejectMilestone(uint256 projectId, uint256 milestoneIndex, string memory reason)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(milestone.status == MilestoneStatus.Submitted, \"Milestone not submitted\");\n\n        milestone.status = MilestoneStatus.InProgress;\n        milestone.submittedAt = 0;\n        milestone.submissionNote = \"\";\n\n        emit MilestoneRejected(projectId, milestoneIndex, reason);\n    }\n\n    /**\n     * @notice Client marks milestone as completed (legacy support)\n     * @dev Equivalent to approve for backwards compatibility\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function completeMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        require(\n            milestone.status != MilestoneStatus.Approved && milestone.status != MilestoneStatus.Paid,\n            \"Already completed or paid\"\n        );\n\n        milestone.status = MilestoneStatus.Approved;\n        emit MilestoneCompleted(projectId, milestoneIndex);\n    }\n\n    /**\n     * @notice Release payment for completed/approved milestone\n     * @dev Can be called by anyone, but requires milestone to be completed/approved or timed out\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function releaseMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        nonReentrant\n        validMilestoneIndex(projectId, milestoneIndex)\n    {\n        Project storage project = projects[projectId];\n        require(project.active, \"Project not active\");\n\n        Milestone storage milestone = project.milestones[milestoneIndex];\n        require(milestone.status != MilestoneStatus.Paid, \"Already paid\");\n\n        bool isApproved = milestone.status == MilestoneStatus.Approved;\n        bool isTimedOut = block.timestamp >= milestone.createdAt + TIMEOUT_PERIOD;\n        bool canRelease = isApproved || isTimedOut;\n\n        require(canRelease, \"Not ready to release\");\n\n        // Calculate PM fee\n        uint256 pmFee = (milestone.amount * project.pmFeeBps) / BPS_DENOMINATOR;\n        uint256 freelancerAmount = milestone.amount - pmFee;\n\n        // Update state before external calls\n        milestone.status = MilestoneStatus.Paid;\n        project.totalPaid += milestone.amount;\n        project.totalPmFees += pmFee;\n\n        // Transfer to freelancer\n        (bool s1,) = project.freelancer.call{value: freelancerAmount}(\"\");\n        require(s1, \"Transfer failed\");\n\n        // Transfer to PM (if exists and fee > 0)\n        if (project.pm != address(0) && pmFee > 0) {\n            (bool s2,) = project.pm.call{value: pmFee}(\"\");\n            require(s2, \"PM transfer failed\");\n        }\n\n        emit MilestonePaid(projectId, milestoneIndex, milestone.amount, isTimedOut);\n    }\n\n    /**\n     * @notice Cancel project and refund unpaid milestones to client\n     * @dev Can only be called by client for projects with no approved/submitted milestones\n     * @param projectId The project ID\n     */\n    function cancelProject(uint256 projectId)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        nonReentrant\n    {\n        Project storage project = projects[projectId];\n\n        // Calculate refund amount (only unpaid milestones that aren't approved/submitted)\n        uint256 refundAmount = 0;\n        bool hasInProgressWork = false;\n\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            MilestoneStatus status = project.milestones[i].status;\n            if (status == MilestoneStatus.Approved || status == MilestoneStatus.Submitted) {\n                hasInProgressWork = true;\n                break;\n            }\n            if (status != MilestoneStatus.Paid) {\n                refundAmount += project.milestones[i].amount;\n            }\n        }\n\n        require(!hasInProgressWork, \"Cannot cancel with approved or submitted milestones\");\n        require(refundAmount > 0, \"No funds to refund\");\n\n        // Mark project as inactive and all unpaid milestones as paid\n        project.active = false;\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            if (project.milestones[i].status != MilestoneStatus.Paid) {\n                project.milestones[i].status = MilestoneStatus.Paid;\n            }\n        }\n\n        // Refund to client\n        (bool success, ) = project.client.call{value: refundAmount}(\"\");\n        require(success, \"Refund failed\");\n\n        emit ProjectCancelled(projectId, refundAmount);\n    }\n\n    /**\n     * @notice Emergency withdrawal for specific milestone\n     * @dev Client can reclaim funds from a milestone that cannot be paid\n     * @param projectId The project ID\n     * @param milestoneIndex Index of the milestone\n     */\n    function emergencyReclaim(uint256 projectId, uint256 milestoneIndex)\n        external\n        onlyClient(projectId)\n        projectActive(projectId)\n        validMilestoneIndex(projectId, milestoneIndex)\n        nonReentrant\n    {\n        Project storage project = projects[projectId];\n        Milestone storage milestone = project.milestones[milestoneIndex];\n\n        require(milestone.status != MilestoneStatus.Paid, \"Already paid\");\n        require(\n            milestone.status != MilestoneStatus.Approved && milestone.status != MilestoneStatus.Submitted,\n            \"Cannot reclaim approved or submitted milestone\"\n        );\n\n        // Must wait longer than normal timeout\n        uint256 emergencyTimeout = milestone.createdAt + (TIMEOUT_PERIOD * 2);\n        require(block.timestamp >= emergencyTimeout, \"Emergency timeout not reached\");\n\n        // Mark as paid to prevent double withdrawal\n        milestone.status = MilestoneStatus.Paid;\n\n        // Return to client\n        (bool success, ) = project.client.call{value: milestone.amount}(\"\");\n        require(success, \"Emergency reclaim failed\");\n\n        emit MilestonePaid(projectId, milestoneIndex, milestone.amount, true);\n    }\n\n    /**\n     * @notice Get project details\n     */\n    function getProject(uint256 projectId) external view returns (\n        address client,\n        address freelancer,\n        address pm,\n        uint256 pmFeeBps,\n        uint256 totalAmount,\n        uint256 totalPaid,\n        uint256 totalPmFees,\n        bool active,\n        uint256 milestoneCount\n    ) {\n        Project storage project = projects[projectId];\n        return (\n            project.client,\n            project.freelancer,\n            project.pm,\n            project.pmFeeBps,\n            project.totalAmount,\n            project.totalPaid,\n            project.totalPmFees,\n            project.active,\n            project.milestones.length\n        );\n    }\n\n    /**\n     * @notice Get milestone details\n     */\n    function getMilestone(uint256 projectId, uint256 milestoneIndex)\n        external\n        view\n        validMilestoneIndex(projectId, milestoneIndex)\n        returns (\n            string memory description,\n            uint256 amount,\n            uint256 createdAt,\n            uint256 submittedAt,\n            MilestoneStatus status,\n            string memory submissionNote,\n            bool canAutoRelease,\n            uint256 timeUntilAutoRelease\n        )\n    {\n        Milestone storage milestone = projects[projectId].milestones[milestoneIndex];\n        bool autoRelease = block.timestamp >= milestone.createdAt + TIMEOUT_PERIOD;\n\n        uint256 timeLeft = 0;\n        if (!autoRelease) {\n            timeLeft = (milestone.createdAt + TIMEOUT_PERIOD) - block.timestamp;\n        }\n\n        return (\n            milestone.description,\n            milestone.amount,\n            milestone.createdAt,\n            milestone.submittedAt,\n            milestone.status,\n            milestone.submissionNote,\n            autoRelease,\n            timeLeft\n        );\n    }\n\n    /**\n     * @notice Get all milestones for a project\n     * @dev Returns arrays of milestone data for easier frontend consumption\n     */\n    function getAllMilestones(uint256 projectId) external view returns (\n        string[] memory descriptions,\n        uint256[] memory amounts,\n        MilestoneStatus[] memory statuses,\n        uint256[] memory submittedAts,\n        string[] memory submissionNotes\n    ) {\n        Project storage project = projects[projectId];\n        uint256 length = project.milestones.length;\n\n        descriptions = new string[](length);\n        amounts = new uint256[](length);\n        statuses = new MilestoneStatus[](length);\n        submittedAts = new uint256[](length);\n        submissionNotes = new string[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Milestone storage milestone = project.milestones[i];\n            descriptions[i] = milestone.description;\n            amounts[i] = milestone.amount;\n            statuses[i] = milestone.status;\n            submittedAts[i] = milestone.submittedAt;\n            submissionNotes[i] = milestone.submissionNote;\n        }\n\n        return (descriptions, amounts, statuses, submittedAts, submissionNotes);\n    }\n\n    /**\n     * @notice Get project statistics\n     */\n    function getProjectStats(uint256 projectId) external view returns (\n        uint256 totalMilestones,\n        uint256 completedMilestones,\n        uint256 paidMilestones,\n        uint256 remainingAmount\n    ) {\n        Project storage project = projects[projectId];\n        uint256 completed = 0;\n        uint256 paid = 0;\n\n        for (uint256 i = 0; i < project.milestones.length; i++) {\n            MilestoneStatus status = project.milestones[i].status;\n            if (status == MilestoneStatus.Approved || status == MilestoneStatus.Paid) {\n                completed++;\n            }\n            if (status == MilestoneStatus.Paid) {\n                paid++;\n            }\n        }\n\n        return (\n            project.milestones.length,\n            completed,\n            paid,\n            project.totalAmount - project.totalPaid\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}